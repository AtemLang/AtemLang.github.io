"use strict";(self.webpackChunkstd_atem_doc=self.webpackChunkstd_atem_doc||[]).push([[556],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>f});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var u=a.createContext({}),s=function(e){var t=a.useContext(u),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},c=function(e){var t=s(e.components);return a.createElement(u.Provider,{value:t},e.children)},p="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,u=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),p=s(n),d=i,f=p["".concat(u,".").concat(d)]||p[d]||m[d]||r;return n?a.createElement(f,o(o({ref:t},c),{},{components:n})):a.createElement(f,o({ref:t},c))}));function f(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,o=new Array(r);o[0]=d;var l={};for(var u in t)hasOwnProperty.call(t,u)&&(l[u]=t[u]);l.originalType=e,l[p]="string"==typeof e?e:i,o[1]=l;for(var s=2;s<r;s++)o[s]=n[s];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},6969:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>u,contentTitle:()=>o,default:()=>m,frontMatter:()=>r,metadata:()=>l,toc:()=>s});var a=n(7462),i=(n(7294),n(3905));const r={},o="Function",l={unversionedId:"Language/Functions/Function",id:"Language/Functions/Function",title:"Function",description:"Functions are self-contained chunks of code that perform a specific task. You give a function a name that identifies what it does, and this name is used to call the function to perform its task when needed.",source:"@site/docs/02-Language/05-Functions/Function.md",sourceDirName:"02-Language/05-Functions",slug:"/Language/Functions/Function",permalink:"/docs/Language/Functions/Function",draft:!1,editUrl:"https://github.com/AtemLang/atem/tree/main/packages/create-docusaurus/templates/shared/docs/02-Language/05-Functions/Function.md",tags:[],version:"current",frontMatter:{},sidebar:"documentSidebar",previous:{title:"Variables",permalink:"/docs/Language/Variables"},next:{title:"Lambda",permalink:"/docs/Language/Functions/Lambda"}},u={},s=[{value:"Defining and Calling Functions",id:"defining-and-calling-functions",level:2},{value:"Function Parameters",id:"function-parameters",level:2},{value:"Function Return Values",id:"function-return-values",level:2},{value:"Named Function Parameters",id:"named-function-parameters",level:2},{value:"Function Parameter Directives",id:"function-parameter-directives",level:2},{value:"Variadic Function Parameter",id:"variadic-function-parameter",level:2},{value:"Function Types",id:"function-types",level:2},{value:"Nested Functions",id:"nested-functions",level:2},{value:"Pure Functions",id:"pure-functions",level:2}],c={toc:s},p="wrapper";function m(e){let{components:t,...n}=e;return(0,i.kt)(p,(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"function"},"Function"),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"Functions")," are self-contained chunks of code that perform a specific task. You give a function a name that identifies what it does, and this name is used to call the function to perform its task when needed."),(0,i.kt)("p",null,"Like many other functional programming languages, functions are first-class citizens of Atem. You can assign them to the variables, pass them as parameters, return them from functions, or declare nested functions. The unified syntax of declaring variables and functions also implies the similarity between them:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-atem"},"//a variable\nfoo: i8 = 3;\n\n//a function\nbar: func = {};\n")),(0,i.kt)("p",null,"Every functions in Atem has its own types, consisting of the function's parameter types, return type, annotations, and contracts. You can use these types like any other types in Atem."),(0,i.kt)("h2",{id:"defining-and-calling-functions"},"Defining and Calling Functions"),(0,i.kt)("p",null,"Basically, a function definition contains the following parts (The list is ordered):"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Function Name, the function names (usually) describes what functions do."),(0,i.kt)("li",{parentName:"ol"},"Column ",(0,i.kt)("inlineCode",{parentName:"li"},":"),", indicating you are defining some object."),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("em",{parentName:"li"},"(Optional)")," Contracts, providing function's requirements of arguments."),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("em",{parentName:"li"},"(Optional)")," Annotations, transforming the function behavior."),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("em",{parentName:"li"},"(Optional)")," Parameter List, describing what argument the function would take."),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("em",{parentName:"li"},"(Optional)"),' Function Literal "Arrow" ',(0,i.kt)("inlineCode",{parentName:"li"},"->"),', indicating that we are defining some "mapping" between function parameters and function return values.'),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("em",{parentName:"li"},"(Optional)")," Return Type, describing what function will return."),(0,i.kt)("li",{parentName:"ol"},"Function Declarator ",(0,i.kt)("inlineCode",{parentName:"li"},"function"),", indicating that we are defining a function."),(0,i.kt)("li",{parentName:"ol"},"Assignment ",(0,i.kt)("inlineCode",{parentName:"li"},"="),', indicating that you are "assign" a function body to a "variable".'),(0,i.kt)("li",{parentName:"ol"},"Function Body, containing the function's code."),(0,i.kt)("li",{parentName:"ol"},"Semicolon ",(0,i.kt)("inlineCode",{parentName:"li"},";"),", indicating we are done with current statement.")),(0,i.kt)("p",null,"Despite being a long list, many items of the list is optional and can be omitted if you don't need them. A simplest function definition just need to contains 1. 2. 8. 9. 10. 11. Consider the following example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-atem"},'//The simplest function definition you could write in Atem\nsimplest: function = {\n    println("Hello World!");\n};\n')),(0,i.kt)("p",null,'In the example above, the defined a function named "simplest". The function ',(0,i.kt)("inlineCode",{parentName:"p"},"simplest")," takes no parameters and return no values. When called, the function will output ",(0,i.kt)("inlineCode",{parentName:"p"},'"Hello World!"')," in the console."),(0,i.kt)("p",null,"To call our function, we need to use the function name and an argument list:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-atem"},"simplest();\n")),(0,i.kt)("p",null,"The line above will call our ",(0,i.kt)("inlineCode",{parentName:"p"},"simplest")," function."),(0,i.kt)("h2",{id:"function-parameters"},"Function Parameters"),(0,i.kt)("p",null,"Real-world functions usually takes ",(0,i.kt)("em",{parentName:"p"},"lots")," of parameters to work. Luckily, Atem provides a well-defined syntaxes and mechanics to handle the most use cases well. "),(0,i.kt)("p",null,"Typically, a function parameter is consisted of (The list is ordered):"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("em",{parentName:"li"},"(Optional)")," Parameter Label, the name for parameter in the function calling."),(0,i.kt)("li",{parentName:"ol"},"Parameter Name, the name for parameter in the function body."),(0,i.kt)("li",{parentName:"ol"},"Column ",(0,i.kt)("inlineCode",{parentName:"li"},":"),", indicating we are doing some declarations."),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("em",{parentName:"li"},"(Optional)")," Parameter Directives, specifying what way will the parameter pass."),(0,i.kt)("li",{parentName:"ol"},"Parameter Type, describing what type of values that the parameter will accept.")),(0,i.kt)("p",null,"To add parameters to a function, you will need to write a function type literal ",(0,i.kt)("inlineCode",{parentName:"p"},"() -> ()"),"  before the function declarator:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-atem"},"simple_print: (msg: string) -> () function = {\n    println(msg);\n};\n")),(0,i.kt)("p",null,"You can add multiple parameters to the function by separating parameters with comma ",(0,i.kt)("inlineCode",{parentName:"p"},",")," in the parameter list:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-atem"},'complex_print: (msg: string, terminator: string) -> () function = {\n    print("msg$terminator$");\n};\n')),(0,i.kt)("h2",{id:"function-return-values"},"Function Return Values"),(0,i.kt)("p",null,"Functions aren't required to have a return type. But if your function has parameter list, you still need to explicitly write the function return type (which will be ",(0,i.kt)("inlineCode",{parentName:"p"},"void")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"()")," in this case)."),(0,i.kt)("p",null,"To return some value from function, you need to specify a type to describe what type of value the function will return. Consider the ",(0,i.kt)("inlineCode",{parentName:"p"},"power")," example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-atem"},"power: (base: f64, exp: i32) -> double function = {\n    return f64**exp;\n};\n")),(0,i.kt)("p",null,"When a function has a return type, every possible return value should be the same type or at least implicit convertible to the return type, otherwise a compile error will occur:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-atem"},'error_return: (typename: string) -> i32 function = {\n    typename match {\n        "i8" = {return 3:i8;}   //Good, the returned value is implicitly convertible to the return type\n        "i32" = {return 3:i32}  //Good, the returned value is the same type of return type\n        "bool" = {return true;} //ERROR, Type "bool" is not implicitly convertible to the return type "i32"\n    };\n};\n')),(0,i.kt)("p",null,"If a function is called with return values be ignored, a error will occur:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-atem"},'sin(1); //ERROR, Ignoring return values from function call "sin(1)"\n')),(0,i.kt)("p",null,"To avoid this, you can assign the return value to the placeholder ",(0,i.kt)("inlineCode",{parentName:"p"},"_"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-atem"},"_ = sin(1);\n")),(0,i.kt)("p",null,"Or add a ",(0,i.kt)("inlineCode",{parentName:"p"},"@noReturnCheck")," annotation to the function:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-atem"},"sin: @noReturnCheck (value: f64) -> f64 = {...};\n\nsin(1);\n")),(0,i.kt)("p",null,"Or just turn the safety profile off:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-atem"},"@compileTimeSafetyProfile(safety.compiletime.ruleset.no_return_value_ignorance, false);\nsin\n")),(0,i.kt)("h2",{id:"named-function-parameters"},"Named Function Parameters"),(0,i.kt)("h2",{id:"function-parameter-directives"},"Function Parameter Directives"),(0,i.kt)("h2",{id:"variadic-function-parameter"},"Variadic Function Parameter"),(0,i.kt)("h2",{id:"function-types"},"Function Types"),(0,i.kt)("h2",{id:"nested-functions"},"Nested Functions"),(0,i.kt)("h2",{id:"pure-functions"},"Pure Functions"))}m.isMDXComponent=!0}}]);